<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>xmega-usb: max-3420.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>max-3420.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;inttypes.h&gt;</code><br/>
<code>#include &lt;avr/io.h&gt;</code><br/>
<code>#include &lt;avr/pgmspace.h&gt;</code><br/>

<p><a href="max-3420_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#aa8d0c390d3090ac50d07d57de7bd3b49">MAX_INT1_ENABLE</a>&#160;&#160;&#160;PORTE.INT0MASK |= PIN0_bm</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a1bc33c3dcbfb8f50a6f1486f0d4c9fbd">MAX_INT1_ACTIVE</a>&#160;&#160;&#160;bit_is_clear(PORTE.IN, PIN0_bp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a84cbf66aba36f1b7dc4fc791d7b409db">MAX_INT1_INACTIVE</a>&#160;&#160;&#160;bit_is_set(PORTE.IN, PIN0_bp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade7055cc5a288f8c781d6b3f937f7c91"></a><!-- doxytag: member="max&#45;3420.h::vBusHi" ref="ade7055cc5a288f8c781d6b3f937f7c91" args="()" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>vBusHi</b>()&#160;&#160;&#160;1</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="max-3420_8h.html#a967f278119ef5d36b773302c733cd040">usbEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a77091d4f21b50585c2e3f5e6afc567e2">usbEvent_t</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a967f278119ef5d36b773302c733cd040">usbEvent</a> { <br/>
&#160;&#160;<b>USB_VBUS_LOST</b>, 
<b>BUS_RESET</b>, 
<b>SETUP_PACKET_AVAILABLE</b>, 
<b>EP0_OUT_DATA</b>, 
<br/>
&#160;&#160;<b>EP1_OUT_DATA</b>, 
<b>USB_SUSPEND</b>, 
<b>USB_EVENT_ERROR</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#ae05f46e396d7b3595db96129769b0b1e">initMax3420</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#ac551b9e06492b519fa633a97987eb477">initUsb</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a2f84328ff03656413944a108b950828d">terminateUsb</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#af34a91acee4d06103ec78f28c40bc63b">maxPowerDown</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="max-3420_8h.html#a77091d4f21b50585c2e3f5e6afc567e2">usbEvent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a057d096ed96855d0dfbdeca53892e961">getUsbEvent</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a56b9daf7ac43f1c4dd3dfe06123be134">getSetupPacket</a> (uint8_t *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a7333c77ad204d4689aeeccd5a94f2615">setDeviceAddress</a> (uint8_t address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a476685b39ecb3b9495a6df4073e82d68">usbSuspend</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a37fada0e467766a63faff09614645e8e">stallEp</a> (uint8_t ep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#ae8ec3e1cfef5cfb4c8f9dd4a592db97e">clearStallEp</a> (uint8_t ep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a08ca1932ba03e58da529a921b864d24c">isEpStalled</a> (uint8_t ep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a2de8094f2b1cb1e3dd3e26adcbb3153e">writeEp0</a> (uint8_t *buffer, uint8_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#ac58a0da3e51dfb894c4c8d7504990f17">writeEp0_P</a> (prog_uint8_t *buffer, uint8_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#aaa8b63a0809812ccf3d9cb256fa15b2a">ackStatus</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#ad928c7022748643e4e84b33cfb40d6d2">readEp1</a> (uint8_t *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#aa42977edd2526b8583a45c9f8c26822a">writeEp2</a> (uint8_t *buffer, uint8_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max-3420_8h.html#a8204ae56942050537c7bcfd947b2a63a">writeEp2_P</a> (prog_uint8_t *buffer, uint8_t length)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>max-3420-usb.h xmega-usb</p>
<p>Copyright (c) 2010 Martin Clemons</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>Header file for basic SPI communication with MAXIM 3420E USB Peripheral Controller.</p>
<p>MAX3420 is connected to XMEGA USART peripheral, which is configured to run in master SPI mode. Using the USART peripheral as opposed to the SPI peripheral allows use of additional hardware data buffers thus simplifying interface code.</p>
<p>In addition to SPI interface connections, INT1 pin from MAX3420 is connected to a GPIO pin on the XMEGA to facilitate asynchronous detection of MAX3420 interrupts on the AVR. Finally, a method needs to be in place to detect the presence of USB bus voltage in a self powered USB device. This is implemented externally and may require the connection of MAX3420 GPX pin to the AVR. See "MAX3420E Programming Guide" HOSCSTEN programming notes for more details. In this case vBus detection is provided externally by vBusHi(). </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1bc33c3dcbfb8f50a6f1486f0d4c9fbd"></a><!-- doxytag: member="max&#45;3420.h::MAX_INT1_ACTIVE" ref="a1bc33c3dcbfb8f50a6f1486f0d4c9fbd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INT1_ACTIVE&#160;&#160;&#160;bit_is_clear(PORTE.IN, PIN0_bp)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if MAX3420 INT1 pin is low </p>

</div>
</div>
<a class="anchor" id="aa8d0c390d3090ac50d07d57de7bd3b49"></a><!-- doxytag: member="max&#45;3420.h::MAX_INT1_ENABLE" ref="aa8d0c390d3090ac50d07d57de7bd3b49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INT1_ENABLE&#160;&#160;&#160;PORTE.INT0MASK |= PIN0_bm</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable AVR interrupt to detect low level on MAX3420 INT1 pin. NOTE: Since AVR interrupt handler disables further pin interrupts the interrupt needs to be enabled before each use. </p>

</div>
</div>
<a class="anchor" id="a84cbf66aba36f1b7dc4fc791d7b409db"></a><!-- doxytag: member="max&#45;3420.h::MAX_INT1_INACTIVE" ref="a84cbf66aba36f1b7dc4fc791d7b409db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INT1_INACTIVE&#160;&#160;&#160;bit_is_set(PORTE.IN, PIN0_bp)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if MAX3420 INT1 pin is not low </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a77091d4f21b50585c2e3f5e6afc567e2"></a><!-- doxytag: member="max&#45;3420.h::usbEvent_t" ref="a77091d4f21b50585c2e3f5e6afc567e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="max-3420_8h.html#a967f278119ef5d36b773302c733cd040">usbEvent</a>  <a class="el" href="max-3420_8h.html#a77091d4f21b50585c2e3f5e6afc567e2">usbEvent_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Event codes returned by <a class="el" href="max-3420_8c.html#a057d096ed96855d0dfbdeca53892e961">getUsbEvent()</a></p>
<ul>
<li>USB_VBUS_LOST<br/>
 USB Bus voltage not present, as determined by external function vBusHi().</li>
<li>BUS_RESET<br/>
 USB Reset has been detected. Returned when bus reset is complete and private maxProcessBusReset() function has completed.</li>
<li>SETUP_PACKET_AVAILABLE<br/>
 A USB setup packed has been received and is valid. Automatically clears stall flag on EP0.</li>
<li>EP0_OUT_DATA<br/>
 Endpoint 0 Out has data available (unused - SETUP_PACKET_AVAILABLE used instead).</li>
<li>EP1_OUT_DATA<br/>
 Endpoint 1 Out has data available.</li>
<li>USB_SUSPEND<br/>
 USB suspend condition detected (no bus traffic for 3ms). This event will be returned every 3 ms until <a class="el" href="max-3420_8c.html#a476685b39ecb3b9495a6df4073e82d68">usbSuspend()</a> is called which clears interrupt and powers down MAX3420, thus terminating further suspend events. See MAXIM AN3661 "SUSP Interrupt Request Bit".<br/>
 Since unplugging of a USB device will also cause an absence of USB traffic, but a small amount of time is required to discharge USB vBus capacitors, it is likely that this event will also be returned when a self powered device is unplugged before the USB_VBUS_LOST event is returned.<br/>
 This is the main reason external function vBusHi() is required. Since the proper response to a suspend event may be powering down the MAX3420, and the MAX3420 VBUS interrupts require the '3420 oscillator to be running to update, an asynchronous method is required to detect the loss of Vbus.</li>
<li>USB_EVENT_ERROR<br/>
 A MAX3420 interrupt has been generated, but none of the interrupt flags are set to cause the return of any of the above events. </li>
</ul>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a967f278119ef5d36b773302c733cd040"></a><!-- doxytag: member="max&#45;3420.h::usbEvent" ref="a967f278119ef5d36b773302c733cd040" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="max-3420_8h.html#a967f278119ef5d36b773302c733cd040">usbEvent</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Event codes returned by <a class="el" href="max-3420_8c.html#a057d096ed96855d0dfbdeca53892e961">getUsbEvent()</a></p>
<ul>
<li>USB_VBUS_LOST<br/>
 USB Bus voltage not present, as determined by external function vBusHi().</li>
<li>BUS_RESET<br/>
 USB Reset has been detected. Returned when bus reset is complete and private maxProcessBusReset() function has completed.</li>
<li>SETUP_PACKET_AVAILABLE<br/>
 A USB setup packed has been received and is valid. Automatically clears stall flag on EP0.</li>
<li>EP0_OUT_DATA<br/>
 Endpoint 0 Out has data available (unused - SETUP_PACKET_AVAILABLE used instead).</li>
<li>EP1_OUT_DATA<br/>
 Endpoint 1 Out has data available.</li>
<li>USB_SUSPEND<br/>
 USB suspend condition detected (no bus traffic for 3ms). This event will be returned every 3 ms until <a class="el" href="max-3420_8c.html#a476685b39ecb3b9495a6df4073e82d68">usbSuspend()</a> is called which clears interrupt and powers down MAX3420, thus terminating further suspend events. See MAXIM AN3661 "SUSP Interrupt Request Bit".<br/>
 Since unplugging of a USB device will also cause an absence of USB traffic, but a small amount of time is required to discharge USB vBus capacitors, it is likely that this event will also be returned when a self powered device is unplugged before the USB_VBUS_LOST event is returned.<br/>
 This is the main reason external function vBusHi() is required. Since the proper response to a suspend event may be powering down the MAX3420, and the MAX3420 VBUS interrupts require the '3420 oscillator to be running to update, an asynchronous method is required to detect the loss of Vbus.</li>
<li>USB_EVENT_ERROR<br/>
 A MAX3420 interrupt has been generated, but none of the interrupt flags are set to cause the return of any of the above events. </li>
</ul>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aaa8b63a0809812ccf3d9cb256fa15b2a"></a><!-- doxytag: member="max&#45;3420.h::ackStatus" ref="aaa8b63a0809812ccf3d9cb256fa15b2a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ackStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the MAX3420 ACKSTAT bit </p>

</div>
</div>
<a class="anchor" id="ae8ec3e1cfef5cfb4c8f9dd4a592db97e"></a><!-- doxytag: member="max&#45;3420.h::clearStallEp" ref="ae8ec3e1cfef5cfb4c8f9dd4a592db97e" args="(uint8_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearStallEp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>ep</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear stalled endpoint specified in ep.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint which should be un-stalled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56b9daf7ac43f1c4dd3dfe06123be134"></a><!-- doxytag: member="max&#45;3420.h::getSetupPacket" ref="a56b9daf7ac43f1c4dd3dfe06123be134" args="(uint8_t *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t getSetupPacket </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"> <em>buffer</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get USB setup packet from '3420 FIFO and transfer into buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to buffer into which setup data is read (8 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a057d096ed96855d0dfbdeca53892e961"></a><!-- doxytag: member="max&#45;3420.h::getUsbEvent" ref="a057d096ed96855d0dfbdeca53892e961" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="max-3420_8h.html#a77091d4f21b50585c2e3f5e6afc567e2">usbEvent_t</a> getUsbEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for MAX3420 interrupt, then decode IRQ bits to determine which USB even caused interrupt.<br/>
 Some events have automatic internal processing, and all events return corresponding event code. Only events which have interrupt enabled will initially cause IRQ wait loop to terminate, although all IRQ flags in USBIRQ and EPIRQ will be tested.<br/>
 The first flag to match a certain test will be returned, regardless of whether that particular flag caused the interrupt.</p>
<p>The USB_VBUS_LOST event is special in that it will terminate the interrupt wait routine and has the highest priority.</p>
<p>Function calls sleep_mode() while waiting for MAX3420 interrupt, so sleep mode should be such that the INT1 signal or Vbus loss signal can wake the AVR.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns usb event. </dd></dl>

</div>
</div>
<a class="anchor" id="ae05f46e396d7b3595db96129769b0b1e"></a><!-- doxytag: member="max&#45;3420.h::initMax3420" ref="ae05f46e396d7b3595db96129769b0b1e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initMax3420 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize interface to MAX3420 USB controller.<br/>
 Communication with MAX3420 will utilize the XMEGA USART in SPI Master mode.<br/>
 SPI clock should be highest frequency possible (fcpu/2) since MAX3420E supports frequencies of up to 26MHz. Clock phase and polarity are XMEGA defaults - data valid on rising edge of clock. SPI interface will be full-duplex ('3420 FDUPSPI bit = 1).<br/>
 MAX3420 INT pin output set to low level when interrupts are active.<br/>
 MAX3420 will be set to sleep mode when initialization is complete. </p>

</div>
</div>
<a class="anchor" id="ac551b9e06492b519fa633a97987eb477"></a><!-- doxytag: member="max&#45;3420.h::initUsb" ref="ac551b9e06492b519fa633a97987eb477" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initUsb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to initialize MAX3420 USB connection<br/>
 Sets MAX3420 USB interface to known state and sets configuration for initial USB enumeration. Function enables URESDN interrupt and enables connection of pull-up resistor on Vbus detection. </p>

</div>
</div>
<a class="anchor" id="a08ca1932ba03e58da529a921b864d24c"></a><!-- doxytag: member="max&#45;3420.h::isEpStalled" ref="a08ca1932ba03e58da529a921b864d24c" args="(uint8_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t isEpStalled </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>ep</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks stall condition of endpoint specified in ep.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 if endpoint is stalled, 0 if not stalled. </dd></dl>

</div>
</div>
<a class="anchor" id="af34a91acee4d06103ec78f28c40bc63b"></a><!-- doxytag: member="max&#45;3420.h::maxPowerDown" ref="af34a91acee4d06103ec78f28c40bc63b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxPowerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets MAX3420 power down bit </p>

</div>
</div>
<a class="anchor" id="ad928c7022748643e4e84b33cfb40d6d2"></a><!-- doxytag: member="max&#45;3420.h::readEp1" ref="ad928c7022748643e4e84b33cfb40d6d2" args="(uint8_t *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t readEp1 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"> <em>buffer</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from MAX3240 Endpoint 1 Out FIFO.<br/>
 Function waits for endpoint data available IRQ bit to be set, then reads EP1OUTBC register to determinine number of bytes in endpoint FIFO.<br/>
 This number of bytes is read from the FIFO and stored in buffer, and then returned. Aborts read and returns 0 if setup data available, usb reset, or usb suspend IRQ bits are set.</p>
<p>NOTE: buffer passed to function must be at least 64 bytes, since maximum read length is MAX3420 FIFO buffer size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to buffer to read into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read from EP1. </dd></dl>

</div>
</div>
<a class="anchor" id="a7333c77ad204d4689aeeccd5a94f2615"></a><!-- doxytag: member="max&#45;3420.h::setDeviceAddress" ref="a7333c77ad204d4689aeeccd5a94f2615" args="(uint8_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDeviceAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>address</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set USB address of device.<br/>
 This is accomplished automatically by the MAX3420, so this function just sets ACKSTAT bit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The new address of the device (ignored) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37fada0e467766a63faff09614645e8e"></a><!-- doxytag: member="max&#45;3420.h::stallEp" ref="a37fada0e467766a63faff09614645e8e" args="(uint8_t ep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stallEp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>ep</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stalls endpoint specified in ep. Since endpoint direction is fixed by MAX3420 hardware, it is not necessary to specify a direction to identify a specific endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Enpoint which should be stalled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f84328ff03656413944a108b950828d"></a><!-- doxytag: member="max&#45;3420.h::terminateUsb" ref="a2f84328ff03656413944a108b950828d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void terminateUsb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call this function to terminate USB connection.<br/>
 Resets and puts MAX3420 into power down mode.<br/>
 NOTE: No MAX3420 interrupts are enabled. </p>

</div>
</div>
<a class="anchor" id="a476685b39ecb3b9495a6df4073e82d68"></a><!-- doxytag: member="max&#45;3420.h::usbSuspend" ref="a476685b39ecb3b9495a6df4073e82d68" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbSuspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears MAX3420 suspend interrupt and powers down '3420.<br/>
 Should be called immediately after USB_SUSPEND is returned by <a class="el" href="max-3420_8c.html#a057d096ed96855d0dfbdeca53892e961">getUsbEvent()</a> to comply with USB timing specifications.<br/>
 See MAXIM AN3661 "SUSP Interrupt Request Bit". </p>

</div>
</div>
<a class="anchor" id="a2de8094f2b1cb1e3dd3e26adcbb3153e"></a><!-- doxytag: member="max&#45;3420.h::writeEp0" ref="a2de8094f2b1cb1e3dd3e26adcbb3153e" args="(uint8_t *buffer, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t writeEp0 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write length bytes from buffer to endpoint0IN.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer from which to write endpoint. </td></tr>
    <tr><td class="paramname">length</td><td>Length in bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ac58a0da3e51dfb894c4c8d7504990f17"></a><!-- doxytag: member="max&#45;3420.h::writeEp0_P" ref="ac58a0da3e51dfb894c4c8d7504990f17" args="(prog_uint8_t *buffer, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t writeEp0_P </td>
          <td>(</td>
          <td class="paramtype">prog_uint8_t *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same functionality as writeToEp0In except utilizing buffer in program memory.<br/>
 Used to transmit program memory constants to endpoint 0 in.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Program space buffer from which to write endpoint. </td></tr>
    <tr><td class="paramname">length</td><td>Length in bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, 1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa42977edd2526b8583a45c9f8c26822a"></a><!-- doxytag: member="max&#45;3420.h::writeEp2" ref="aa42977edd2526b8583a45c9f8c26822a" args="(uint8_t *buffer, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t writeEp2 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to MAX3420 Endpoint 2 In FIFO.<br/>
 Function waits for endpoint buffer available IRQ bit to be set, then writes length bytes from buffer to MAX3420 EP2 FIFO.<br/>
 Aborts write and returns 1 if setup data available, usb reset, or usb suspend IRQ bits are set.</p>
<p>NOTE: Maximum length is MAX3420 FIFO size of 64 bytes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to buffer to write from. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 on failure, 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a8204ae56942050537c7bcfd947b2a63a"></a><!-- doxytag: member="max&#45;3420.h::writeEp2_P" ref="a8204ae56942050537c7bcfd947b2a63a" args="(prog_uint8_t *buffer, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t writeEp2_P </td>
          <td>(</td>
          <td class="paramtype">prog_uint8_t *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to MAX3420 Endpoint 2 In FIFO from buffer in program space.<br/>
 Same as writeEp2 except using buffer in program memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to program space buffer to write from. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 on failure, 0 on success. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Dec 11 2010 00:07:36 for xmega-usb by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
